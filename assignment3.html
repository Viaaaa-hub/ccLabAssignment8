<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignment 1</title>
  <link rel="stylesheet" href="assignment.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>

<body>
  <!-- Top Navigation -->
  <header class="top-nav">
    <div class="logo">HAOFEI HAN</div>
    <nav class="nav-links">
      <a href="index.html#home">HOME</a>
      <a href="index.html#about">ABOUT ME</a>
      <a href="index.html#projects" class="active">PROJECTS</a>
    </nav>
  </header>

  <main>
  <div class="assignment-block">
    <h1>Assignment 3</h1>

    <!-- Sketch -->
    <div id="sketch-container"></div>

    <h2 class="reflection-title">Reflection</h2>
    <div class="reflection">
      My experimental clock is called the Memory Puzzle Clock. The canvas is divided into 60 grids, which are gradually filled within a minute. Each second, a new puzzle piece appears at a random position, like a small memory fragment or an unexpected surprise in life. Within the same minute, pieces share the same shape, while the color saturation gradually deepens, and a new color family is introduced each hour. Through the changes in shape, the filling of the grid, and the shifting colors, this clock tracks time in a way that makes its passage more playful and story-like.

When I thought about the theme of time, I associated it with keywords such as speed, growth, and emotion, and based on these keywords, I designed three different clocks. I then realized that all these concepts are closely connected to memory—time is filled with fragments of memory. Therefore, I decided to choose puzzle fragments as the theme of my experimental clock. I divided the canvas into 60 small grids, and each second one grid is filled with a shape. Within a minute, the entire canvas becomes filled once, and every hour the color scheme of the shapes is updated. To make the clock more playful, the next grid to be filled is chosen randomly. To further distinguish each minute, I allowed the shape of the pieces to be randomly selected from rectangles, triangles, ellipses, and pentagons. However, I noticed that sometimes the same shape would appear for several minutes in a row, so I added a new rule: the saturation of the shapes gradually increases within each hour, reflecting the progress of time. Since saturation cannot increase endlessly, at the start of each new hour, the clock switches to a new color family and begins the cycle again.

Through this assignment, I practiced how to work with time in code and deepened my understanding of using if else statements. I realized that if else can simplify the handling of more complex situations without the need to repeatedly write large amounts of code. I also came to see that time is not just numbers or endlessly rotating hands on a clock—it can be represented in many creative ways to capture its passage. The most enjoyable part of this assignment was that, as I kept thinking about the theme of memory fragments, many beautiful past memories surfaced in my mind. This made me feel that code can also carry warmth and emotion. 
    </div>
  </div>
</main>

  <footer>
    <p>© Haofei Han 2025</p>
  </footer>

  <!-- p5.js Sketch -->
<script>
let pieces = [];      
let positions = [];   
let lastSecond = -1;
let lastMinute = -1;
let baseHue;
let minuteColor;
let shapeTheme;
let minuteStep = 0;

function setup() {
  const canvas = createCanvas(600, 600);
  canvas.parent('sketch-container');
  colorMode(HSB, 360, 100, 100);
  noStroke();
  initPositions();

  baseHue = int(random(360));
  setMinuteStyle();
}

function draw() {
  background(0, 0, 95);

  let s = second();
  let m = minute();

  //a piece per sec
  if (s != lastSecond && positions.length > 0) {
    lastSecond = s;

    let pos = positions.pop();

    pieces.push({
      x: pos.x,
      y: pos.y,
      w: pos.w,
      h: pos.h,
      c: minuteColor,
      type: shapeTheme
    });
  }

  for (let p of pieces) {
    fill(p.c);

    if (p.type == 0) {
      rectMode(CENTER);
      rect(p.x, p.y, p.w, p.h);
    } else if (p.type == 1) {
      ellipse(p.x, p.y, p.w, p.h);
    } else if (p.type == 2) {
      triangle(
        p.x - p.w / 2, p.y + p.h / 2,
        p.x + p.w / 2, p.y + p.h / 2,
        p.x, p.y - p.h / 2
      );
    } else if (p.type == 3) {
      beginShape();
      for (let a = 0; a < TWO_PI; a += TWO_PI / 5) {
        let vx = p.x + cos(a) * p.w / 2;
        let vy = p.y + sin(a) * p.h / 2;
        vertex(vx, vy);
      }
      endShape(CLOSE);
    }
  }

  // per min
  if (s == 0 && m != lastMinute) {
    lastMinute = m;

    minuteStep++;
    setMinuteStyle();

    pieces = [];
    initPositions();
  }

  // per hour
  if (m == 0 && s == 0) {
    baseHue = int(random(360));
    minuteStep = 0;
    setMinuteStyle();
  }
  
}


function initPositions() {
  positions = [];
  let cols = 10;
  let rows = 6;
  let w = width / cols;
  let hBlock = height / rows;

  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      positions.push({
        x: col * w + w / 2,
        y: row * hBlock + hBlock / 2,
        w: w,
        h: hBlock
      });
    }
  }
  shuffle(positions, true);
}

function setMinuteStyle() {

  let saturation = map(minuteStep, 0, 59, 5, 100);
  let brightness = 90;

  minuteColor = color(baseHue, saturation, brightness);

  //shape per min
  shapeTheme = int(random(4));
}


</script>
</body>
</html>
