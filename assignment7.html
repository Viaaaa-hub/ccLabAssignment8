<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignment 1</title>
  <link rel="stylesheet" href="assignment.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Figtree:wght@400;600&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
</head>

<body>
  <!-- Top Navigation -->
  <header class="top-nav">
    <div class="logo">HAOFEI HAN</div>
    <nav class="nav-links">
      <a href="index.html#home">HOME</a>
      <a href="index.html#about">ABOUT ME</a>
      <a href="index.html#projects" class="active">PROJECTS</a>
    </nav>
  </header>

  <main>
  <div class="assignment-block">
    <h1>Assignment 7</h1>

    <!-- Sketch -->
    <div id="sketch-container">
  </div>

    <h2 class="reflection-title">Reflection</h2>
    <div class="reflection">
      For this assignment, we were asked to create a game with three levels. During the ideation stage, I drew inspiration from my own cultural background and decided to design a game centered around making dumplings. In my culture, dumplings hold deep significance. They represent family and reunion, and before setting off on a long journey, it is customary for us to eat dumplings as a wish for safety. Dumplings are also eaten during important occasions and festivals, such as the Lunar New Year, as a way of celebration. These traditions became the main source of inspiration for this project.
In the first level of the game, the player uses the W, A, S, and D keys to control the character’s movement around the map and collect meat and flour. When the amount of both meat and flour reaches at least five, the player can advance to the next level.
In the second level, the player uses the mouse to drag and drop ingredients into two separate bowls for mixing. Water and flour go into one bowl, while meat and scallions go into the other. If an ingredient is dragged into the wrong bowl, it returns to its original position when the mouse is released. After both mixtures are completed, the player advances to the third level.
In the third level, the player clicks the two bowls containing the mixed ingredients in a specific order, representing the process of wrapping dumplings. At this point, a dumpling begins to follow the mouse cursor. The player then clicks on the pot to place the dumpling inside. After clicking again, the single dumpling turns into two, symbolizing that they are fully cooked. These two dumplings then follow the mouse together. When the cooked dumplings are placed onto the plate, the game is completed, and the words “Flavour of Home” appear on the screen.
Even when using the same recipe, dumplings from different families always taste slightly different. This subtle difference is what we call the flavour of home.
During the development process, I encountered several challenges. The first was figuring out how to represent the act of wrapping dumplings. Since I couldn’t recreate the full wrapping process through simple interactions, I decided to use clicking and state changes to symbolize each step instead. This led to a second challenge: designing the dumpling’s different states. For this part, I created four distinct dumpling states, and each transition required careful and logical planning to make sure the flow felt consistent. The transitions between levels required the same kind of structured thinking as well.
Finally, in terms of visuals, if I had the chance to iterate further, I would like to draw the images myself. That would allow me to adjust the colors and achieve a more cohesive and harmonious look overall.

    </div>
  </div>
</main>

  <footer>
    <p>© Haofei Han 2025</p>
  </footer>

  <!-- p5.js Sketch -->
<script>
  //variables for level one
const TILE_EMPTY = 0;
const TILE_BLOCK = 1;
const TILE_MEAT = 2;
const TILE_FLOUR  = 3;

const TILE_SIZE = 30;
const MEAT_SIZE = 30;
const FLOUR_SIZE  = 30;

let MEAT_NUM = 0;
let FLOUR_NUM = 0;

//create a class for level one
class LevelOne{
  constructor() {
    
    //matrix map
    this.map = [
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0],
      [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,1,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,1,0,0],
      [0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],
      [0,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0],
      [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0],
      [0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],
      [0,2,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,2,0,0,0,1,1,1,0,0,0,0,0,0,0],
      [0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,3,0],
      [0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1],
      [0,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0],
    ];
  }
  
  //draw the map
  drawMe() {
    for (let i = 0; i < this.map.length; i++) {
      for (let j = 0; j < this.map[i].length; j++) {
        const t = this.map[i][j];
        const x = j * TILE_SIZE;
        const y = i * TILE_SIZE;

        if (t === TILE_BLOCK) {
          // noStroke();
          // fill(170);
          // rect(x, y, TILE_SIZE, TILE_SIZE);
          image(blockImg,x, y, TILE_SIZE, TILE_SIZE);
        } else if (t === TILE_MEAT) {
          image(meatImg,x, y, MEAT_SIZE, MEAT_SIZE )
        } else if (t === TILE_FLOUR) {
          image(flourImg,x, y, FLOUR_SIZE, FLOUR_SIZE )
        }
      }
    }
  }
  
  drawUI() {
    fill(0);
    textSize(16);
    text("MEAT: " + MEAT_NUM, 10, 20)
    text("FLOUR: " + FLOUR_NUM, 150, 20)
  }
}
//hit detect
function hitRect(px, py, rx, ry, rw, rh) {
  return (px >= rx && px <= rx + rw && py >= ry && py <= ry + rh);
}

// draw dumpling
function drawDumpling(x, y, cooked) {
  push();
  translate(x, y);
  noStroke();
  if (!cooked) {
    image(dumplingUncookedImg,-30,-15, 40, 20);
  } else {
    image(dumplingImg,-30,-15, 40, 20);
  }
  pop();
}

// level three make dumplings
class LevelThree {

  drawMe() {
    textAlign(CENTER, CENTER);
    textSize(14);

    //bowls
    let bowlOneX = 50, bowlOneY = 360, bowlOneW = 120, bowlOneH = 80;
    let bowlTwoX = 160, bowlTwoY = 390, bowlTwoW = 120, bowlTwoH = 80;

    // pot and plate
    let potX = 290, potY = 300, potW = 140, potH = 140;
    let plateX = 450, plateY = 420, plateW = 120, plateH = 35;

    // draw bowls, pot, and plate
    image(bowl1fillImg,bowlOneX, bowlOneY, bowlOneW, bowlOneH);
    image(bowl2fillImg,bowlTwoX, bowlTwoY, bowlTwoW, bowlTwoH);
    image(potImg,potX, potY, potW, potH);
    image(plateImg,plateX, plateY, plateW, plateH);

    // dumping stage
    let potCenterX = potX + potW / 2;
    let potCenterY = potY + potH / 2;
    let plateCenterX = plateX + plateW / 2;
    let plateCenterY = plateY + plateH / 2;

    if (dumplingStage === 1) {
      drawDumpling(mouseX, mouseY, false);
    } else if (dumplingStage === 2) {
      drawDumpling(potCenterX+5, potCenterY-10, false);
    } else if (dumplingStage === 3) {
      drawDumpling(mouseX, mouseY, true);
    } else if (dumplingStage === 4) {
      drawDumpling(plateCenterX, plateCenterY, true);
    }
    
    if (dumplingStage === 4) {
      push();
      noStroke();

      fill(75, 46, 43, 153); 
      rect(0, 150, 600, 300);

      fill(255);
      textAlign(CENTER, CENTER);
      textSize(36);
      text("Flavor of Home", width / 2, height / 2);
      pop();
    }
  }
  
  

  // mouse interact
  handleMousePressed(mx, my) {
    let skinBowlX = 50, skinBowlY = 360, skinBowlW = 120, skinBowlH = 80;
    let fillBowlX = 160, fillBowlY = 390, fillBowlW = 120, fillBowlH = 80;
    let potX = 290, potY = 300, potW = 140, potH = 140;
    let plateX = 450, plateY = 420, plateW = 120, plateH = 35;

    // make dumpling
    if (dumplingStage === 0) {
      if (!clickedBowl1 && hitRect(mx, my, skinBowlX, skinBowlY, skinBowlW, skinBowlH)) {
        clickedBowl1 = true;
        return;
      }
      if (clickedBowl1 && hitRect(mx, my, fillBowlX, fillBowlY, fillBowlW, fillBowlH)) {
        clickedBowl1 = false;
        dumplingStage = 1;
        return;
      }
    }

    // put dumpling into the pot
    if (dumplingStage === 1) {
      if (hitRect(mx, my, potX, potY, potW, potH)) {
        dumplingStage = 2;
        return;
      }
    }

    // cooked dumpling
    if (dumplingStage === 2) {
      if (hitRect(mx, my, potX, potY, potW, potH)) {
        dumplingStage = 3;
        return;
      }
    }

    // put dumpling into the plate
    if (dumplingStage === 3) {
      if (hitRect(mx, my, plateX, plateY, plateW, plateH)) {
        dumplingStage = 4;
        return;
      }
    }
  }
}
class LevelTwo {

  drawMe() {
    textAlign(CENTER, CENTER);
    textSize(14);

    let flourX = 60,  flourY = 350, flourW = 80, flourH = 80;
    let waterX = 180, waterY = 370, waterW = 80, waterH = 50;
    let meatX  = 60,  meatY  = 430, meatW  = 80, meatH  = 40;
    let scalX  = 180, scalY  = 430, scalW = 80, scalH = 40;

    let bowlOneX = 300, bowlOneY = 360, bowlOneW = 120, bowlOneH = 80;
    let bowlTwoX = 450, bowlTwoY = 360, bowlTwoW = 120, bowlTwoH = 80;

    // flour
    if (!flourUsed) {
      // fill(180);
      if (draggingItem === "flour") {
        image(flourImg,mouseX - 40, mouseY - 20, flourW, flourH);
      } else {
        image(flourImg,flourX, flourY, flourW, flourH);
      }
    }

    // water
    if (!waterUsed) {
      // fill(180);
      if (draggingItem === "water") {
        image(waterImg,mouseX - 40, mouseY - 20, waterW, waterH);
      } else {
        image(waterImg, waterX, waterY, waterW, waterH);
      }
    }

    // meat
    if (!meatUsed) {
      // fill(180);
      if (draggingItem === "meat") {
        image(meatImg,mouseX - 40, mouseY - 20, meatW, meatH);
      } else {
        image(meatImg,meatX, meatY, meatW, meatH);
      }
    }

    // scallion
    if (!scallionUsed) {
      // fill(180);
      if (draggingItem === "scallion") {
        image(scallionImg,mouseX - 40, mouseY - 20, scalW, scalH);
      } else {
        image(scallionImg,scalX, scalY, scalW, scalH);
      }
    }

    // bowl 1
    if (bowlOneComplete) {
      image(bowl1fillImg,bowlOneX, bowlOneY, bowlOneW, bowlOneH);
    }
    else{
      image(bowl1Img,bowlOneX, bowlOneY, bowlOneW, bowlOneH);
    }

    // bowl 2
    if (bowlTwoComplete) {
      image(bowl2fillImg,bowlTwoX, bowlTwoY, bowlTwoW, bowlTwoH);
    }
    else{
      image(bowl2Img,bowlTwoX, bowlTwoY, bowlTwoW, bowlTwoH);
    }
  }

  // mouse interact
  handleMousePressed(mx, my) {
    let flourX = 60,  flourY = 350, flourW = 80, flourH = 80;
    let waterX = 180, waterY = 370, waterW = 80, waterH = 50;
    let meatX  = 60,  meatY  = 430, meatW  = 80, meatH  = 40;
    let scalX  = 180, scalY  = 430, scalW = 80, scalH = 40;

    if (!flourUsed && this.inRect(mx, my, flourX, flourY, flourW, flourH)) {
      draggingItem = "flour";
    } else if (!waterUsed && this.inRect(mx, my, waterX, waterY, waterW, waterH)) {
      draggingItem = "water";
    } else if (!meatUsed && this.inRect(mx, my, meatX, meatY, meatW, meatH)) {
      draggingItem = "meat";
    } else if (!scallionUsed && this.inRect(mx, my, scalX, scalY, scalW, scalH)) {
      draggingItem = "scallion";
    }
  }

  handleMouseDragged(mx, my) {
    
  }

  // mouse released
  handleMouseReleased(mx, my) {
    if (draggingItem == null) return;

    let bowlOneX = 300, bowlOneY = 360, bowlOneW = 120, bowlOneH = 80;
    let bowlTwoX = 450, bowlTwoY = 360, bowlTwoW = 120, bowlTwoH = 80;

    // flour and water only to bowl 1
    if (draggingItem === "flour" || draggingItem === "water") {
      if (this.inRect(mx, my, bowlOneX, bowlOneY, bowlOneW, bowlOneH)) {
        if (draggingItem === "flour") {
          bowlOne_flour = true;
          flourUsed = true;
        }
        if (draggingItem === "water") {
          bowlOne_water = true;
          waterUsed = true;
        }
      }
    }

    // meat and scallion only to bowl 2
    if (draggingItem === "meat" || draggingItem === "scallion") {
      if (this.inRect(mx, my, bowlTwoX, bowlTwoY, bowlTwoW, bowlTwoH)) {
        if (draggingItem === "meat") {
          bowlTwo_meat = true;
          meatUsed = true;
        }
        if (draggingItem === "scallion") {
          bowlTwo_scallion = true;
          scallionUsed = true;
        }
      }
    }

    bowlOneComplete = (bowlOne_flour && bowlOne_water);
    bowlTwoComplete = (bowlTwo_meat && bowlTwo_scallion);

    draggingItem = null;
  }

  inRect(px, py, rx, ry, rw, rh) {
    return (px >= rx && px <= rx + rw && py >= ry && py <= ry + rh);
  }
}
class Player {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 30;
    this.speed = 2.5;
  }

  display() {
    image(playerImg,this.x, this.y, this.size, this.size);
  }
  
  playerUpdate() {
    let posX = this.x;
    let posY = this.y;

    if (keyIsDown(65)) posX -= this.speed; // A - left
    if (keyIsDown(68)) posX += this.speed; // D - right
    if (keyIsDown(87)) posY -= this.speed; // W - up
    if (keyIsDown(83)) posY += this.speed; // S - down

    let posPlayer = {
      left: posX,
      right: posX + this.size,
      top: posY,
      bottom: posY + this.size
    };

    let collision = false;

    for (let i = 0; i < level1.map.length; i++) {
      for (let j = 0; j < level1.map[i].length; j++) {
        const t = level1.map[i][j];
        if (t === TILE_BLOCK) {
          const bx = j * TILE_SIZE;
          const by = i * TILE_SIZE;
          const blockRect = {
            left: bx,
            right: bx + TILE_SIZE,
            top: by,
            bottom: by + TILE_SIZE
          };

          if (
            posPlayer.right > blockRect.left &&
            posPlayer.left < blockRect.right &&
            posPlayer.bottom > blockRect.top &&
            posPlayer.top < blockRect.bottom
          ) {
            collision = true;
            break;
          }
        }
      }
      if (collision) break;
    }

    if (!collision) {
      this.x = constrain(posX, 0, width - this.size);
      this.y = constrain(posY, 0, height - this.size);
    }

    let tileX = floor((this.x + this.size / 2) / TILE_SIZE);
    let tileY = floor((this.y + this.size / 2) / TILE_SIZE);

    tileX = constrain(tileX, 0, level1.map[0].length - 1);
    tileY = constrain(tileY, 0, level1.map.length - 1);

    let tileType = level1.map[tileY][tileX];

    if (tileType === TILE_MEAT) {
      level1.map[tileY][tileX] = TILE_EMPTY;
      MEAT_NUM += 1;
    } else if (tileType === TILE_FLOUR) {
      level1.map[tileY][tileX] = TILE_EMPTY;
      FLOUR_NUM += 1;
    }
  }
}
//variables needed
let level;
let level1;
let level2;
let level3;
let player;

let levelState = 0;

//veriables for level 2
let draggingItem = null;

let flourUsed = false;
let waterUsed = false;
let meatUsed = false;
let scallionUsed = false;

let bowlOne_flour = false;
let bowlOne_water = false;
let bowlTwo_meat = false;
let bowlTwo_scallion = false;

let bowlOneComplete = false;
let bowlTwoComplete = false;

//veriables for level 3
let dumplingStage = 0;  
let clickedBowl1 = false;

//images
let flourImg;
let waterImg;
let meatImg;
let scallionImg;
let dumplingImg;
let dumplingUncookedImg;
let potImg;
let plateImg;
let playerImg;
let blockImg;
let bowl1Img;
let bowl1fillImg;
let bowl2Img;
let bowl2fillImg;
let bg1Img;
let bg2Img;


function preload() {
  flourImg = loadImage('Images/flour.png');
  waterImg = loadImage('Images/water.png');
  meatImg = loadImage('Images/meat.png');
  scallionImg = loadImage('Images/scallion.png');
  dumplingImg = loadImage('Images/dumpling.png');
  dumplingUncookedImg = loadImage('Images/dumpling1.png');
  potImg = loadImage('Images/pot.png');
  plateImg = loadImage('Images/plate.png');
  playerImg = loadImage('Images/player.png');
  blockImg = loadImage('Images/block.png');
  bowl1Img = loadImage('Images/bowl1.png');
  bowl1fillImg = loadImage('Images/bowl1fill.png');
  bowl2Img = loadImage('Images/bowl2.png');
  bowl2fillImg = loadImage('Images/bowl2fill.png');
  bg1Img = loadImage('Images/bg1.png');
  bg2Img = loadImage('Images/bg2.png');
}


function setup() {
  const canvas = createCanvas(20 * TILE_SIZE, 20 * TILE_SIZE);
  canvas.parent('sketch-container');

  level1 = new LevelOne();
  level2 = new LevelTwo();
  level3 = new LevelThree();

  player = new Player(50, 50);
}

function draw() {
  if(levelState === 0){
    image(bg1Img,0,0,20 * TILE_SIZE, 20 * TILE_SIZE);
    }
  else if(levelState === 1 || levelState === 2){
    image(bg2Img,0,0,20 * TILE_SIZE, 20 * TILE_SIZE);
  }

  //change to level 2
  if (levelState === 0 && MEAT_NUM >= 5 && FLOUR_NUM >= 5) {
    levelState = 1;
  }

  //change to level 3
  if (levelState === 1 && bowlOneComplete && bowlTwoComplete) {
    levelState = 2;
  }

  //what need to be called in three levels
  if (levelState === 0) {
    level1.drawMe();
    level1.drawUI();
    player.display();
    player.playerUpdate();
  } else if (levelState === 1) {
    level2.drawMe();
  } else if (levelState === 2) {
    level3.drawMe();
  }
}

function mousePressed() {
  if (levelState === 1) {
    level2.handleMousePressed(mouseX, mouseY);
  } else if (levelState === 2) {
    level3.handleMousePressed(mouseX, mouseY);
  }
}

function mouseDragged() {
  if (levelState === 1) {
    level2.handleMouseDragged(mouseX, mouseY);
   } 
  else if (levelState === 2) {
  }
}

function mouseReleased() {
  if (levelState === 1) {
    level2.handleMouseReleased(mouseX, mouseY);
  }
}


</script>


</body>
</html>
